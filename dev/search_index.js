var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Abstract-types","page":"Reference","title":"Abstract types","text":"","category":"section"},{"location":"reference/#Creating-a-directed-hypergraph","page":"Reference","title":"Creating a directed hypergraph","text":"","category":"section"},{"location":"reference/#Manipulating-vertices-and-hyperedges","page":"Reference","title":"Manipulating vertices and hyperedges","text":"","category":"section"},{"location":"reference/#Hypergraph-array-getters-and-setters","page":"Reference","title":"Hypergraph array getters and setters","text":"For a directed hypergraph, an additional index can refer to either the tail (1) or head (2) of a directed hyperedge:\n\ndh = DirectedHypergraph{Int64}(2,3);\ndh[1,1,1] = 1;\ndh[2,2,1] = 2;\ndh\n\n# output\n\n2×3 DirectedHypergraph{Int64, Nothing, Nothing, Dict{Int64, Int64}}:\n (1, nothing)  (nothing, nothing)  (nothing, nothing)\n (nothing, 2)  (nothing, nothing)  (nothing, nothing)\n\nSetting with slices is not currently possible, and users must currently use slices on the component undirected hypergraphs instead. However, accessing using slices is allowed:\n\ndh = DirectedHypergraph{Int64}(4,2);\ndh.hg_tail[1:2,1] .= 1;\ndh.hg_head[3:4,1] .= 2;\ndh[:,1]\n\n# output\n\n4-element Vector{Tuple{Union{Nothing, Int64}, Union{Nothing, Int64}}}:\n (1, nothing)\n (1, nothing)\n (nothing, 2)\n (nothing, 2)","category":"section"},{"location":"reference/#Hypergraph-info","page":"Reference","title":"Hypergraph info","text":"","category":"section"},{"location":"reference/#Modifying-a-directed-hypergraph","page":"Reference","title":"Modifying a directed hypergraph","text":"","category":"section"},{"location":"reference/#Pathfinding","page":"Reference","title":"Pathfinding","text":"","category":"section"},{"location":"reference/#I/O","page":"Reference","title":"I/O","text":"Directed hypergraphs can be saved as and loaded from JSON- and EHGF-formatted files, where the EHGF format is a close derivative of HGF.","category":"section"},{"location":"reference/#Graph-utilities","page":"Reference","title":"Graph utilities","text":"","category":"section"},{"location":"reference/#SimpleDirectedHypergraphs.AbstractDirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.AbstractDirectedHypergraph","text":"AbstractDirectedHypergraph{T} <: AbstractSimpleHypergraph{T}\n\nAn abstract directed hypergraph type storing information about vertices and hyperedges.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SimpleDirectedHypergraphs.DirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.DirectedHypergraph","text":"DirectedHypergraph{T} <: AbstractDirectedHypergraph{Tuple{Union{T, Nothing}, Union{T, Nothing}}}\n\nA directed hypergraph storing information about vertices and hyperedges.\n\nThis implementation is based on guidance from Przemysław Szufel;     see https://github.com/pszufe/SimpleHypergraphs.jl/issues/45 This allows us to manipulate DirectedHypergraphs using Hypergraph functionality There is danger of a user manipulating individual hg_tail and hg_head (undirected) hypergraphs Is there a smart way to prevent this? TODO: reconsider this design choice\n\nConstructors\n\nDirectedHypergraph{T,V,E,D}(\n    n::Integer, k::Integer,\n    v_meta=Vector{Union{V, Nothing}}(nothing, n),\n    he_meta_tail=Vector{Union{E, Nothing}}(nothing, k),\n    he_meta_head=Vector{Union{E, Nothing}}(nothing, k)\n) where {T<:Real,V,E,D<:AbstractDict{Int, T}}\nDirectedHypergraph{T,V,E}(n::Integer, k::Integer) where {T<:Real, V, E}\nDirectedHypergraph{T,V}(n::Integer, k::Integer) where {T<:Real, V}\nDirectedHypergraph{T}(n::Integer, k::Integer) where {T<:Real}\nDirectedHypergraph(n::Integer, k::Integer)\n\nConstruct a hypergraph with a given number of vertices and hyperedges. Optionally, values of type V can be stored at vertices and values of type E can be stored at hyperedges. By default the hypergraph uses a Dict{Int,T} for the internal data storage, however a different dictionary such as SortedDict to ensure result replicability can be used (e.g., when doing stochastic simulations on directed hypergraphs).\n\nDirectedHypergraph(\n    m_tail::AbstractMatrix{Union{T, Nothing}},\n    m_head::AbstractMatrix{Union{T, Nothing}}\n) where {T<:Real}    \nDirectedHypergraph{T}(\n    m_tail::AbstractMatrix{Union{T, Nothing}},\n    m_head::AbstractMatrix{Union{T, Nothing}}\n) where {T<:Real}\nDirectedHypergraph{T,V}(\n    m_tail::AbstractMatrix{Union{T, Nothing}},\n    m_head::AbstractMatrix{Union{T, Nothing}};\n    v_meta::Vector{Union{Nothing,V}}=Vector{Union{Nothing,V}}(nothing, size(m,1)),\n) where {T<:Real,V}\nDirectedHypergraph{T,E}(\n    m_tail::AbstractMatrix{Union{T, Nothing}},\n    m_head::AbstractMatrix{Union{T, Nothing}};\n    he_meta_tail::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(m,2)),\n    he_meta_head::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(m,2))\n) where {T<:Real,E}\nDirectedHypergraph{T,V,E}(\n    m_tail::AbstractMatrix{Union{T, Nothing}},\n    m_head::AbstractMatrix{Union{T, Nothing}};\n    v_meta::Vector{Union{Nothing,V}}=Vector{Union{Nothing,V}}(nothing, size(m,1)),\n    he_meta_tail::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(m,2)),\n    he_meta_head::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(m,2))\n) where {T<:Real,V,E}\nDirectedHypergraph{T,V,E,D}(\n    m_tail::AbstractMatrix{Union{T, Nothing}},\n    m_head::AbstractMatrix{Union{T, Nothing}};\n    v_meta::Vector{Union{Nothing,V}}=Vector{Union{Nothing,V}}(nothing, size(m,1)),\n    he_meta_tail::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(m,2)),\n    he_meta_head::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(m,2))\n) where {T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nConstruct a directed hypergraph using its matrix representation. In the matrix representation rows are vertices and columns are hyperedges. Optionally, values of type V can be stored at vertices and values of type E can be stored at hyperedges. By default the hypergraph uses a Dict{Int,T} for the internal data storage, however a different dictionary such as SortedDict to ensure result replicability can be used (e.g. when doing stochastic simulations on hypergraphs).\n\nDirectedHypergraph(g::Graphs.DiGraph)\n\nConstructs a directed hypergraph of degree 2 by making a deep copy of a Graphs.DiGraph. A SortedDict will be used for internal data storage of the hypergraph.\n\nDirectedHypergraph(\n    hg_tail::Hypergraph{T},\n    hg_head::Hypergraph{T}\n) where {T<:Real}\nDirectedHypergraph{T}(\n    hg_tail::Hypergraph{T},\n    hg_head::Hypergraph{T}\n) where {T<:Real}\nDirectedHypergraph{T,V}(\n    hg_tail::Hypergraph{T},\n    hg_head::Hypergraph{T};\n    v_meta::Union{Nothing, Vector{Union{V, Nothing}}}=nothing,\n) where {T<:Real,V}\n DirectedHypergraph{T,V,E}(\n    hg_tail::Hypergraph{T},\n    hg_head::Hypergraph{T};\n    v_meta::Union{Nothing, Vector{Union{V, Nothing}}}=nothing,\n    he_meta_tail::Union{Nothing, Vector{Union{E, Nothing}}}=nothing,\n    he_meta_head::Union{Nothing, Vector{Union{E, Nothing}}}=nothing\n) where {T<:Real,V,E}\n DirectedHypergraph{T,V,E,D}(\n    hg_tail::Hypergraph{T,Nothing,Nothing,D},\n    hg_head::Hypergraph{T,Nothing,Nothing,D};\n    v_meta::Vector{Union{Nothing,V}}=Vector{Union{Nothing,V}}(nothing, size(hg_tail,1)),\n    he_meta_tail::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(hg_tail,2)),\n    he_meta_head::Vector{Union{Nothing,E}}=Vector{Union{Nothing,E}}(nothing, size(hg_tail,2))\n) where {T<:Real,V,E,D<:AbstractDict{Int, T}}\n\nConstructs a directed hypergraph from two undirected basic hypergraphs, one with hyperedges containing \"tail\" vertices and one with hyperedges containing \"head\" verticies.\n\nDirectedHypergraph{T,V,E,D}(\n    hg_tail::Hypergraph{T,V,E,D},\n    hg_head::Hypergraph{T,V,E,D}\n) where {T<:Real,V,E,D<:AbstractDict{Int, T}}\n\nConstructs a directed hypergraph from two hypergraphs potentially containing metadata. Throws an error if the vertex metadata of the two hypergraphs is not element-for-element identical.\n\nArguments\n\nT : type of weight values stored in the hypergraph's adjacency matrix\nV : type of values stored in the vertices of the hypergraph\nE : type of values stored in the edges of the hypergraph\nD : dictionary for storing values the default is Dict{Int, T}\nn : number of vertices\nk : number of hyperedges\nm : a matrix representation rows are vertices and columns are hyperedges\ng : a (directed) graph representation of the hypergraph\nhg_tail: an undirected hypergraph representing the tail half of   the directed hypergraph\nhg_head: an undirected hypergraph representing the head half of   the directed hypergraph\n\n\n\n\n\n","category":"type"},{"location":"reference/#SimpleHypergraphs.random_model-Union{Tuple{H}, Tuple{Int64, Int64, Type{H}}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.random_model","text":"random_model(nVertices::Int, nEdges::Int, HType::Type{H}) where {H<:AbstractDirectedHypergraph}\n\nGenerate a random directed hypergraph (in the style of Erdős–Rényi random graphs) without any structural constraints.\n\nThe Algorithm\n\nGiven two integer parameters nVertices and nEdges (the number of nodes and hyperedges, respectively), the algorithm computes - for each hyperedge he={1,...,m} - two random numbers s_t ϵ [1, n] (i.e., the size of the hyperedge tail) and s_h ϵ [1, n] (i.e., the size of the hyperedge head). Then, the algorithm selects uniformly at random s_t vertices from V to be added in the tail of he and s_h vertices from V to be added into the head of he. If noselfloops is true (default false), then vertices will be chosen such that the same vertex v cannot appear in both the head and the tail of the same hyperedge he.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.random_kuniform_model-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.random_kuniform_model","text":"random_kuniform_model(nVertices::Int, nEdges::Int, k::Int; HType::Type{H}=DirectedHypergraph, no_self_loops::Bool=false) where {H<:AbstractDirectedHypergraph}\n\nGenerates a k-uniform directed hypergraph, i.e., an hypergraph where each hyperedge has size k = ktail + khead. In this implementation, k_tail and k_head are not necessarily equal.\n\nThe Algorithm\n\nThe algorithm proceeds as the random_model, forcing the size of each hyperedge equal to k.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.random_dregular_model-Union{Tuple{H}, Tuple{Int64, Int64, Int64, Type{H}}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.random_dregular_model","text":"random_dregular_model(\n    nVertices::Int,\n    nEdges::Int,\n    d::Int,\n    HType::Type{H};\n    no_self_loops::Bool=false\n) where {H<:AbstractDirectedHypergraph}\n\nGenerates a d-regular directed hypergraph, where each node has degree d.\n\nThe Algorithm\n\nThe algorithm exploits the k-uniform approach described for the randomkuniformmodel method to build a d-regular hypergraph H having nVertices nodes and nEdges edges. It returns the hypergraph H^ dual of H.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.add_hyperedge!-Union{Tuple{DirectedHypergraph{T, V, E, D}}, Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.add_hyperedge!","text":"add_hyperedge!(h::DirectedHypergraph{T, V, E, D};\n               vertices_tail::D = D(), vertices_head::D = D(),\n               he_meta_tail::Union{E,Nothing}=nothing, he_meta_head::Union{E,Nothing}=nothing\n               ) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nAdds a hyperedge to a given directed hypergraph h. Optionally, existing vertices can be added to the created hyperedge in the tail or head directions. The paramater vertices_tail represents a dictionary of vertex identifiers and values stored at the tail hyperedge; vertices_head represented the vertex identifiers and values stored at the outcoming side of the hyperedge. Additionally,  a value can be stored with the hyperedge using the he_meta_tail and he_meta_head keyword parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.add_vertex!-Union{Tuple{DirectedHypergraph{T, V, E, D}}, Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.add_vertex!","text":"add_vertex!(h::DirectedHypergraph{T, V, E, D};\n            hyperedges_tail::D = D(), hyperedges_head::D = D(), v_meta::Union{V,Nothing} = nothing\n            ) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nAdds a vertex to a given directed hypergraph h. Optionally, the vertex can be added to existing hyperedges. The hyperedges_tail parameter presents a dictionary of hyperedge identifiers and values stored at the ingoing side of hyperedges, and the hyperedges_head parameter presents a dictionary of hyperedge identifiers and values stored at the head side of hyperedges. Additionally, a value can be stored with the vertex using the v_meta keyword parameter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.set_vertex_meta!-Union{Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}, Tuple{DirectedHypergraph{T, V, E, D}, Union{Nothing, V}, Int64}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.set_vertex_meta!","text":"set_vertex_meta!(h::DirectedHypergraph{T, V, E, D}, new_value::Union{V,Nothing},\n    id::Int) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nSets a new meta value new_value for the vertex id in the hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.get_vertex_meta-Union{Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}, Tuple{DirectedHypergraph{T, V, E, D}, Int64}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.get_vertex_meta","text":"get_vertex_meta(h::DirectedHypergraph{T, V, E, D}, id::Int\n                ) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nReturns a meta value stored at the vertex id in the directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.set_hyperedge_meta!-Union{Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}, Tuple{DirectedHypergraph{T, V, E, D}, Union{Nothing, E}, Union{Nothing, E}, Int64}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.set_hyperedge_meta!","text":"set_hyperedge_meta!(h::DirectedHypergraph{T, V, E, D},\n    new_value_tail::Union{E,Nothing}, new_value_head::Union{E,Nothing}, id::Int\n    ) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nSets a new meta value new_value for the hyperedge id in the directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.set_hyperedge_meta!-Union{Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}, Tuple{DirectedHypergraph{T, V, E, D}, Union{Nothing, E}, Int64, HyperedgeDirection}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.set_hyperedge_meta!","text":"set_hyperedge_meta!(h::DirectedHypergraph{T, V, E, D},\n    new_value::Union{E,Nothing}, id::Int, side::HyperedgeDirection\n    ) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nSets a new meta value new_value for the hyperedge id in the direction side     for a directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.get_hyperedge_meta-Union{Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}, Tuple{DirectedHypergraph{T, V, E, D}, Int64}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.get_hyperedge_meta","text":"get_hyperedge_meta(h::DirectedHypergraph{T, V, E, D}, id::Int)\n    where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nReturns a meta value stored at the hyperedge id in the directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.get_hyperedge_meta-Union{Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}, Tuple{DirectedHypergraph{T, V, E, D}, Int64, HyperedgeDirection}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleHypergraphs.get_hyperedge_meta","text":"get_hyperedge_meta(h::DirectedHypergraph{T, V, E, D}, id::Int, side::HyperedgeDirection)\n    where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nReturns a meta value stored at the hyperedge id in the directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.remove_vertex!-Tuple{DirectedHypergraph, Int64}","page":"Reference","title":"SimpleHypergraphs.remove_vertex!","text":"remove_vertex!(h::DirectedHypergraph, v::Int)\n\nRemoves the vertex v from a given directed hypergraph h. Note that running this function will cause reordering of vertices in the hypergraph; the vertex v will replaced by the last vertex of the hypergraph and the list of vertices will be shrunk.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.remove_hyperedge!-Tuple{DirectedHypergraph, Int64}","page":"Reference","title":"SimpleHypergraphs.remove_hyperedge!","text":"remove_hyperedge!(h::DirectedHypergraph, e::Int)\n\nRemoves the hyperedge e from a given directed hypergraph h. Note that running this function will cause reordering of hyperedges in the hypergraph: the hyperedge e will replaced by the last hyperedge of the hypergraph and the list of hyperedges (and hyperedge metadata) will be shrunk.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Union{Tuple{H}, Tuple{H, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Base.getindex","text":"Base.getindex(h::H, idx::Vararg{Int,2}) where {H <: AbstractDirectedHypergraph}\n\nReturns a value for a given vertex-hyperedge pair idx for a directed hypergraph h. If a vertex does not belong to a hyperedge nothing is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.setindex!-Union{Tuple{H}, Tuple{H, Nothing, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(h::H, ::Nothing, idx::Vararg{Int,2}) where {H <: AbstractDirectedHypergraph}\n\nRemoves a vertex from a given hyperedge for a directed hypergraph h and a given vertex-hyperedge pair idx. Note that trying to remove a vertex from a hyperedge when it is not present will not throw an error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.setindex!-Union{Tuple{H}, Tuple{H, Real, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(h::H, v::Real, idx::Vararg{Int,2}) where {H <: AbstractDirectedHypergraph}\n\nAdds a vertex to a hyperedge (represented by indices idx) and assigns value v to be stored with that assignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.setindex!-Union{Tuple{H}, Tuple{H, Tuple{Union{Nothing, Real}, Union{Nothing, Real}}, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(h::H, v::Tuple{Union{Real, Nothing}, Union{Real, Nothing}}, idx::Vararg{Int,2}) where {H <: AbstractDirectedHypergraph}\n\nManipulates a hyperedge (represented by indices idx), either adding a vertex to the  ingoing and/or head sides of the hyperedge and assigning a value associated with that assignment, or else removing a vertex from the ingoing/head sides of the hyperedge.\n\nHere, v is a 2-tuple where the first element is the value that will be assigned to the ingoing part of the hyperedge and the second element is the value that will be assigned to the head part. A value of nothing means that the vertex will be removed from that side of the hyperedge.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.setindex!-Union{Tuple{H}, Tuple{H, Nothing, Int64, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(h::H, ::Nothing, idx::Vararg{Int,3}) where {H <: AbstractDirectedHypergraph}\n\nRemoves a vertex from a given hyperedge for a directed hypergraph h and a given side-vertex-hyperedge pair idx. If the first index of idx is 1, then the vertex will be removed from the tail hyperedge; if idx is 2, then the vertex will be removed from the head hyperedge.  Note that trying to remove a vertex from a hyperedge when it is not present will not throw an error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.setindex!-Union{Tuple{H}, Tuple{H, Real, Int64, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Base.setindex!","text":"Base.setindex!(h::H, v::Real, idx::Vararg{Int,3}) where {H <: AbstractDirectedHypergraph}\n\nAdds a vertex to a hyperedge (represented by indices idx, where the first index must be either 1 - referring to an tail hyperedge - or 2 - referring to an head hyperedge) and assigns value v to be stored with that assignment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.nhv-Tuple{H} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.nhv","text":"nhv(h::H) where {H <: AbstractDirectedHypergraph}\n\nReturn the number of vertices in the directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.nhe-Tuple{H} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.nhe","text":"nhe(h::H) where {H <: AbstractDirectedHypergraph}\n\nReturn the number of hyperedges in the directed hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.getvertices-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.getvertices","text":"getvertices(h::H, he_id::Int) where {H <: AbstractDirectedHypergraph}\n\nReturns vertices from a directed hypergraph a for a given hyperedge he_id. Vertex indices are given in a tuple (in, out), where in are the tail vertices and out are the head vertices\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.gethyperedges-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.gethyperedges","text":"gethyperedges(h::H, v_id::Int) where {H <: AbstractDirectedHypergraph}\n\nReturns hyperedges for a given vertex v_id in a directed hypergraph h. Hyperedge indices are given in a tuple (tail, head), where tail are the hyperedges where vertex v_ind is on the tail side and head are the hyperedges where v_ind is on the head side.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.get_weakly_connected_components-Tuple{H} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.get_weakly_connected_components","text":"get_weakly_connected_components(h::H) where {H <: AbstractDirectedHypergraph}\n\nReturn an array of weakly connected components in the directed hypergraph h (array of vectors of vertices) by first converting the directed hypergraph into an undirected hypergraph and then obtaining the conected components of that hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.get_strongly_connected_components-Tuple{H} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.get_strongly_connected_components","text":"get_strongly_connected_components(h::H) where {H <: AbstractDirectedHypergraph}\n\nReturn an array of strongly connected components in the directed hypergraph h (array of vectors of vertices), based on the \"naive\" algorithm of Francisco José Martín-Recuerda Moyano (PhD dissertation, 2016).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.get_twosection_adjacency_mx-Union{Tuple{H}, Tuple{T}} where {T<:Real, H<:AbstractDirectedHypergraph{Tuple{Union{Nothing, T}, Union{Nothing, T}}}}","page":"Reference","title":"SimpleHypergraphs.get_twosection_adjacency_mx","text":"get_twosection_adjacency_mx(h::H; count_self_loops::Bool=false,\n                            replace_weights::Union{Nothing,Real}=nothing) where {H<:AbstractDirectedHypergraph}\n\nReturns an adjacency matrix for a two section view of a hypergraph h.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.random_walk-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.random_walk","text":"random_walk(\n    h::H,\n    start::Int;\n    heselect::Function,\n    vselect::Function,\n    reverse::bool\n) where {H <: AbstractDirectedHypergraph}\n\nReturn a next vertex visited in assuming a random walk starting from vertex start. First a hyperedge is sampled with weights proportional to heselect function (by default each hyperedge is sampled with the same probability). Next a vertex within hyperedge is with weights proportional to vselect function (by default each vertex, including the source, is sampled with the same probability).\n\nheselect and vselect functions take two arguments a Hypergraph and respectively a vertex identifier or a hyperedge identifier. The return values of both functions should be respectively a list of hyperedges or vertices and their weights.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.dual-Tuple{DirectedHypergraph}","page":"Reference","title":"SimpleHypergraphs.dual","text":"dual(h::DirectedHypergraph)\n\nReturn the dual of the directed hypergraph h.\n\nNOTE h needs to have at least one dimension greater than 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.to_undirected-Union{Tuple{DirectedHypergraph{T, V, E, D}}, Tuple{D}, Tuple{E}, Tuple{V}, Tuple{T}} where {T<:Real, V, E, D<:AbstractDict{Int64, T}}","page":"Reference","title":"SimpleDirectedHypergraphs.to_undirected","text":"to_undirected(h::DirectedHypergraph)\n\nConverts a directed hypergraph into an undirected hypergraph. Tail and head hyperedges are combined; that is, for all hyperedges heorig in the directed hypergraph h, all vertices in the head or tail are added to a corresponding undirected hyperedge henew in the undirected hypergraph h'.\n\nMetadata is combined into tuples; i.e., if there was originally tail metadata tmeta and head metadata hmeta for a given directed hyperedge, the new undirected hyperedge will have metadata (tmeta, hmeta).\n\nBecause vertex-hyperedge weights are restricted to real numbers, we cannot combine the weights, so we simply set the values to 1.0 if a given vertex is in a given hyperedge \n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.prune_hypergraph!-Tuple{H} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.prune_hypergraph!","text":"prune_hypergraph!(h::H) where {H <: AbstractDirectedHypergraph}\n\nRemove all vertices with degree 0 and all hyperedges of size 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.prune_hypergraph-Tuple{H} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.prune_hypergraph","text":"prune_hypergraph(h::H) where {H <: AbstractDirectedHypergraph}\n\nRemove all vertices with degree 0 and all hyperedges of size 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.shortest_path-Union{Tuple{H}, Tuple{SimpleHypergraphs.BipartiteView{H}, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.shortest_path","text":"shortest_path(b::BipartiteView{H}, source::Int, target::Int) where {H<:AbstractDirectedHypergraph}\n\nFinds a single shortest path in a graph b between vertices source and target. Note that if several paths of the same length exist, only one will be returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.shortest_path-Union{Tuple{H}, Tuple{SimpleHypergraphs.TwoSectionView{H}, Int64, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleHypergraphs.shortest_path","text":"shortest_path(t::TwoSectionView{H}, source::Int, target::Int) where {H<:AbstractDirectedHypergraph}\n\nFinds a single shortest path in a graph b between vertices source and target. Note that if several paths of the same length exist, only one will be returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.forward_reachable-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.forward_reachable","text":"forward_reachable(\n    hg::H,\n    source::Int,\n) where {H <: AbstractDirectedHypergraph}\n\nTraverses a hypergraph `hg` starting from vertex with index `source` to determine all other vertices and hyperedges\nthat are reachable, following hyperedges along their forward direction (i.e., from tail to head).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.backward_traceable-Union{Tuple{H}, Tuple{H, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.backward_traceable","text":"backward_traceable(\n    hg::H,\n    target::Int,\n) where {H <: AbstractDirectedHypergraph}\n\nTraverses a hypergraph `hg` starting from vertex with index `target` to determine all other vertices and hyperedges\nthat are reachable, following hyperedges along their reverse direction (i.e., from head to tail).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.is_reachable-Union{Tuple{H}, Tuple{H, Int64, Int64, Symbol}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"SimpleDirectedHypergraphs.is_reachable","text":"is_reachable(\n    hg::H,\n    source::Int,\n    target::Int,\n    target_type::Symbol\n) where {H<:AbstractDirectedHypergraph}\n\nUse `forward_reachable` to determine if `target` (either a vertex index, if `target_type === :vertex` or a\nhyperedge index if `target_type === :hyperedge`) can be reached from vertex with index`source` in directed\nhypergraph `hg`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleDirectedHypergraphs.all_hyperpaths","page":"Reference","title":"SimpleDirectedHypergraphs.all_hyperpaths","text":"all_hyperpaths(hg::H, source::Int, target::Int) where {H <: AbstractDirectedHypergraph}\n\nall_hyperpaths(\n    hg::DirectedHypergraph{T,V,E,D},\n    source::Int,\n    targets::Set{Int}\n) where {T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nall_hyperpaths(\n    hg::DirectedHypergraph{T,V,E,D},\n    sources::Set{Int},\n    target::Int\n) where {T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nall_hyperpaths(\n    hg::DirectedHypergraph{T,V,E,D},\n    sources::Set{Int},\n    targets::Set{Int}\n) where {T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nExhaustively (but efficiently) generate all hyperpaths in directed hypergraph `hg` from some source(s) to some\ntarget(s), using the algorithm described by Krieger & Kececioglu (2022), DOI: 10.1186/s13015-022-00217-9. \n\nNote that, ostensibly, this algorithm only works for single-source, single-sink pathfinding (i.e., with a single\n`source` index and a single `target` index). If the user provides multiple `sources` and/or multiple `targets`, the\nmulti-source/multi-sink problem will be reformulated as a single-source, single-sink problem by adding a\n*metasource* vertex (connected to all source vertices by a single hyperedge) and/or *metatarget* vertex\n(connected to all target vertices by a single hyperedge).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SimpleDirectedHypergraphs.shortest_hyperpath_kk_heuristic","page":"Reference","title":"SimpleDirectedHypergraphs.shortest_hyperpath_kk_heuristic","text":"shortest_hyperpath_kk_heuristic(\n    hg::H,\n    source::Int,\n    target::Int,\n    hyperedge_weights::AbstractVector{T}\n) where {H <: AbstractDirectedHypergraph, T <: Real}\n\nshortest_hyperpath_kk_heuristic(\n    hg::DirectedHypergraph{T, V, E, D},\n    source::Int,\n    targets::Set{Int},\n    hyperedge_weights::AbstractVector{T}\n) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nshortest_hyperpath_kk_heuristic(\n    hg::DirectedHypergraph{T, V, E, D},\n    sources::Set{Int},\n    target::Int,\n    hyperedge_weights::AbstractVector{T}\n) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nshortest_hyperpath_kk_heuristic(\n    hg::DirectedHypergraph{T, V, E, D},\n    sources::Set{Int},\n    targets::Set{Int},\n    hyperedge_weights::AbstractVector{T}\n) where {T <: Real, V, E, D <: AbstractDict{Int,T}}\n\nImplements the heuristic directed hypergraph pathfinding algorithm of Krieger & Kececioglu (2022),\nDOI: 10.1186/s13015-022-00217-9. This algorithm is not guaranteed to find the optimal pathway from `source` to\n`target` based on some nonnegative `hyperedge_weights`), but in practice, it produces the optimal pathway\napproximately 99% of the time.\n\nNote that, ostensibly, this algorithm only works for single-source, single-sink pathfinding (i.e., with a single\n`source` and a single `target`). If the user provides multiple `sources` and/or multiple `targets`, the\nmulti-source/multi-sink problem will be reformulated as a single-source, single-sink problem by adding a\n*metasource* vertex (connected to all source vertices by a single, 0-cost hyperedge) and/or *metatarget* vertex\n(connected to all target vertices by a single, 0-cost hyperedge).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SimpleDirectedHypergraphs.shortest_hyperpath_kk_ilp","page":"Reference","title":"SimpleDirectedHypergraphs.shortest_hyperpath_kk_ilp","text":"shortest_hyperpath_kk_ilp(\n    hg::H,\n    source::Int,\n    target::Int,\n    hyperedge_weights::AbstractVector{T}\n) where {H<:AbstractDirectedHypergraph, T<:Real}\n\nshortest_hyperpath_kk_ilp(\n    hg::DirectedHypergraph{T,V,E,D},\n    source::Int,\n    targets::Set{Int},\n    hyperedge_weights::AbstractVector{S}\n) where {S<:Real,T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nshortest_hyperpath_kk_ilp(\n    hg::DirectedHypergraph{T,V,E,D},\n    sources::Set{Int},\n    target::Int,\n    hyperedge_weights::AbstractVector{S}\n) where {S<:Real,T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nshortest_hyperpath_kk_ilp(\n    hg::DirectedHypergraph{T,V,E,D},\n    sources::Set{Int},\n    targets::Set{Int},\n    hyperedge_weights::AbstractVector{S}\n) where {S<:Real,T<:Real,V,E,D<:AbstractDict{Int,T}}\n\nImplements the exact directed hypergraph pathfinding algorithm of Krieger & Kececioglu (2023),\nDOI: 10.1089/cmb.2023.0242. This algorithm is guaranteed to find the optimal pathway from `source` to\n`target` based on some nonnegative `hyperedge_weights`, if and only if such a path exists.\n\nNote that, ostensibly, this algorithm only works for single-source, single-sink pathfinding (i.e., with a single\n`source` and a single `target`). If the user provides multiple `sources` and/or multiple `targets`, the\nmulti-source/multi-sink problem will be reformulated as a single-source, single-sink problem by adding a\n*metasource* vertex (connected to all source vertices by a single, 0-cost hyperedge) and/or *metatarget* vertex\n(connected to all target vertices by a single, 0-cost hyperedge).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SimpleDirectedHypergraphs.SnodeDistanceKKHeuristic","page":"Reference","title":"SimpleDirectedHypergraphs.SnodeDistanceKKHeuristic","text":"SnodeDistanceKKHeuristic <: AbstractDistance\n\nConstructor: SnodeDistanceKKHeuristic(sources::Set{Int}, targets::Set{Int}) <: AbstractDistance\n\nRepresent a distance between a set of source nodes (sources) and a set of target nodes (targets) in a directed hypergraph, where a distance in this context is defined as the length of the shortest hyperpath that reaches all t ∈ targets.\n\nThis approach uses the heuristic shortest hyperpath algorithm of Krieger & Kececioglu 2022 (DOI: 10.1186/s13015-022-00217-9). The Krieger & Kececioglu heuristic algorithm commonly (but not always) returns the true optimal (shortest) hyperpath; this algorithm can thus be thought of as an upper bound of the true distance between the sinks and the source. To calculate the exact (minimal) distance, instead use SnodeDistanceKKExact.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SimpleDirectedHypergraphs.SnodeDistanceKKILP","page":"Reference","title":"SimpleDirectedHypergraphs.SnodeDistanceKKILP","text":"SnodeDistanceKKILP <: AbstractDistance\n\nConstructor: SnodeDistanceKKILP(sources::Set{Int}, targets::Set{Int}) <: AbstractDistance\n\nRepresent a distance between a set of source nodes (sources) and a set of target nodes (targets) in a directed hypergraph, where a distance in this context is defined as the length of the shortest hyperpath that reaches all t ∈ targets.\n\nThis approach uses the exact shortest hyperpath algorithm of Krieger & Kececioglu 2023 (DOI: 10.1089/cmb.2023.0242). The Krieger & Kececioglu algorithm solves an integer linear programming formalism related to hypergraph cutting.\n\nFor a lower-cost heuristic algorithm, see SnodeDistanceKKHeuristic.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SimpleHypergraphs.distance-Union{Tuple{T}, Tuple{H}, Tuple{H, SnodeDistanceKKHeuristic, AbstractVector{T}}} where {H<:AbstractDirectedHypergraph, T<:Real}","page":"Reference","title":"SimpleHypergraphs.distance","text":"distance(\n    hg::H,\n    distance_method::SnodeDistanceKKHeuristic,\n    hyperedge_weights::AbstractVector{T};\n) where {H <: AbstractDirectedHypergraph, T <: Real}\n\nReturn the shortest distance between the `distance_method.sources` and the `distance_method.targets`,\nassuming tha the cost (i.e., distance) between two vertices is the sum of the (nonnegative) `hyperedge_weights`\nof the hyperedges in the shortest path between the two sets of vertices. If there is no path between the `sources`\nand `targets`, returns `typemax(T)`.\n\nHere, the heuristic directed hypergraph pathfinding algorithm of Krieger & Kececioglu (2022),\nDOI: 10.1186/s13015-022-00217-9 is used to find the shortest path. This algorithm is not guaranteed to find the\noptimal pathway, but in practice, it produces the optimal pathway approximately 99% of the time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.distance-Union{Tuple{T}, Tuple{H}, Tuple{H, SnodeDistanceKKILP, AbstractVector{T}}} where {H<:AbstractDirectedHypergraph, T<:Real}","page":"Reference","title":"SimpleHypergraphs.distance","text":"distance(\n    hg::H,\n    distance_method::SnodeDistanceKKILP,\n    hyperedge_weights::AbstractVector{T}\n) where {H <: AbstractDirectedHypergraph}\n\nReturn the shortest distance between the `distance_method.sources` and the `distance_method.targets`,\nassuming tha the cost (i.e., distance) between two vertices is the sum of the (nonnegative) `hyperedge_weights`\nof the hyperedges in the shortest path between the two sets of vertices. If there is no path between the `sources`\nand `targets`, returns `typemax(T)`.\n\nHere, the *exact* shortest hyperpath algorithm of Krieger & Kececioglu 2023 (DOI: 10.1089/cmb.2023.0242) is used.\nThe Krieger & Kececioglu algorithm solves an integer linear programming formalism related to hypergraph cutting.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.diameter-Union{Tuple{H}, Tuple{H, SnodeDistanceKKHeuristic}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.diameter","text":"diameter(\n    hg::H,\n    distance_method::SnodeDistanceKKHeuristic,\n) where {H <: AbstractSimpleHypergraph, T <: Real}\n\nReturn the diameter of a hypergraph `hg` (maximum number of hyperedges required to go between any two vertices)\nbased on Krieger & Kececioglu's heuristic algorithm (DOI: 10.1186/s13015-022-00217-9). If there exist some vertices\nnot reachable from other vertices (i.e., if `hg` is not strongly connected), then this will return `Inf`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.diameter-Union{Tuple{H}, Tuple{H, SnodeDistanceKKILP}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.diameter","text":"diameter(\n    hg::H,\n    distance_method::f,\n) where {H <: AbstractSimpleHypergraph, T <: Real}\n\nReturn the diameter of a hypergraph `hg` (maximum number of hyperedges required to go between any two vertices)\nbased on Krieger & Kececioglu's exact integer linear programming algorithm (DOI: 10.1089/cmb.2023.0242). If there\nexist some vertices not reachable from other vertices (i.e., if `hg` is not strongly connected), then this will\nreturn `Inf64`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SimpleHypergraphs.hg_save","page":"Reference","title":"SimpleHypergraphs.hg_save","text":"hg_save(io::IO, h::H, format::EHGF_Format) where {H <: AbstractDirectedHypergraph}\n\nSaves an undirected hypergraph h to an output stream io in ehgf format.\n\nTODO: what to do about metadata?\n\n\n\n\n\nhg_save(io::IO, h::DirectedHypergraph, format::JSON_Format)\n\nSaves a directed hypergraph h to an output stream io in json format.\n\nIf h has Composite Types either for vertex metadata or hyperedges metadata, the user has to explicit tell the JSON3 package about it, for instance using:\n\nJSON3.StructType(::Type{MyType}) = JSON3.Struct().\n\nSee the (JSON3.jl documentation)[https://github.com/quinnj/JSON3.jl] for more details.\n\nThe json in output contains the following information (keys):\n\nn : number of vertices\nk : number of hyperedges\ntail : a matrix representation of the tails of h, where rows are vertices and columns are hyperedges\nhead : a matrix representation of the heads of h, where rows are vertices and columns are hyperedges\nv_meta : vertices metadata\nhe_meta_tail : metadata for hyperedge tails\nhe_meta_head : metadata for hyperedge heads\n\n\n\n\n\n","category":"function"},{"location":"reference/#SimpleDirectedHypergraphs.dhg_load","page":"Reference","title":"SimpleDirectedHypergraphs.dhg_load","text":"dhg_load(\n    io::IO,\n    format::EHGF_Format;\n    HType::Type{H} = DirectedHypergraph,\n    T::Type{U} = Bool,\n    D::Type{<:AbstractDict{Int, U}} = Dict{Int, T},\n) where {U <: Real, H <: AbstractDirectedHypergraph}\n\nLoads a hypergraph from a stream io from ehgf format.\n\nArguments\n\nT : type of weight values stored in the hypergraph's adjacency matrix\nD : dictionary for storing values the default is Dict{Int, T}\n\nSkips a single initial comment.\n\n\n\n\n\ndhg_load(\n    io::IO,\n    T::Type{H},\n    format::JSON_Format;\n    T::Type{U} = Bool,\n    D::Type{<:AbstractDict{Int, U}} = Dict{Int,U},\n    V = Nothing,\n    E = Nothing\n) where {H <: AbstractDirectedHypergraph, U <: Real}\n\nLoads a hypergraph from a stream io from json format.\n\nArguments\n\nT : type of weight values stored in the hypergraph's adjacency matrix\nD : dictionary for storing values the default is Dict{Int, T}\nV : type of values stored in the vertices of the hypergraph\nE : type of values stored in the edges of the hypergraph\n\n\n\n\n\ndhg_load(\n    fname::AbstractString;\n    format::Abstract_HG_format = HGF_Format(),\n    HType::Type{H} = DirectedHypergraph,\n    T::Type{U} = Bool,\n    D::Type{<:AbstractDict{Int, U}} = Dict{Int, T},\n    V = Nothing,\n    E = Nothing\n) where {U <: Real, H <: AbstractDirectedHypergraph}\n\nLoads a hypergraph from a file fname. The default saving format is hgf.\n\nArguments\n\nHType: type of hypergraph to store data in\nT : type of weight values stored in the hypergraph's adjacency matrix\nD : dictionary for storing values the default is Dict{Int, T}\nV : type of values stored in the vertices of the hypergraph\nE : type of values stored in the edges of the hypergraph\n\n\n\n\n\n","category":"function"},{"location":"reference/#Graphs.ne-Union{Tuple{SimpleHypergraphs.BipartiteView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.ne","text":"Return the number of edges in a bipartite view b of a hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.ne-Union{Tuple{SimpleHypergraphs.TwoSectionView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.ne","text":"Return the number of edges in 2-section view t of a directed hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.SimpleGraph-Union{Tuple{SimpleHypergraphs.BipartiteView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.SimpleGraph","text":"Graphs.SimpleGraph(b::BipartiteView{H}) where {H<:AbstractDirectedHypergraph}\n\nCreates a Graphs.SimpleGraph representation of a BipartiteView b.\n\nThis creates a copy of the data. Note that the weights information is not stored in the created SimpleGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{SimpleHypergraphs.BipartiteView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"Graphs.SimpleDiGraph(b::BipartiteView{H}) where {H<:AbstractDirectedHypergraph}\n\nCreates a Graphs.SimpleDiGraph representation of a BipartiteView b.\n\nThis creates a copy of the data. Note that the weights information is not stored in the created SimpleDiGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.SimpleDiGraph-Union{Tuple{SimpleHypergraphs.TwoSectionView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.SimpleDiGraph","text":"Graphs.SimpleGraph(t::TwoSectionView{H}) where {H<:AbstractDirectedHypergraph}\n\nCreates a Graphs.SimpleGraph representation of a TwoSectionView t.\n\nThis creates a copy of the date. Note that the weights information is not stored in the created SimpleGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.badj-Union{Tuple{SimpleHypergraphs.BipartiteView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.badj","text":"Graphs.SimpleGraphs.badj(b::BipartiteView{H}) where {H<:AbstractDirectedHypergraph}\n\nGenerates a backward adjacency list for this view of a directed hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.badj-Union{Tuple{SimpleHypergraphs.TwoSectionView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.badj","text":"Graphs.SimpleGraphs.badj(t::TwoSectionView{H}) where {H<:AbstractDirectedHypergraph}\n\nGenerates an adjency list for this view of a hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.fadj-Union{Tuple{SimpleHypergraphs.BipartiteView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.fadj","text":"Graphs.SimpleGraphs.fadj(b::BipartiteView{H}) where {H<:AbstractDirectedHypergraph}\n\nGenerates a forward adjacency list for this view of a directed hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.SimpleGraphs.fadj-Union{Tuple{SimpleHypergraphs.TwoSectionView{H}}, Tuple{H}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.SimpleGraphs.fadj","text":"Graphs.SimpleGraphs.fadj(t::TwoSectionView{H}) where {H<:AbstractDirectedHypergraph}\n\nGenerates an adjency list for this view of a directed hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.all_neighbors-Union{Tuple{H}, Tuple{SimpleHypergraphs.TwoSectionView{H}, Int64}} where H<:AbstractDirectedHypergraph","page":"Reference","title":"Graphs.all_neighbors","text":"Graphs.all_neighbors(\n    t::TwoSectionView,\n    v::Integer;\n    incoming::Bool = false, outgoing::Bool = true\n) where {H<:AbstractDirectedHypergraph}\n\nReturns N(v) (the vertex v is not included in N(v))\n\nIf incoming is true (default true), include nodes connected to v by directed hyperedges where v is in the head.\n\nIf outgoing is true (default true), include nodes connected to v by directed hyperedges where v is in the tail.\n\nIf both incoming and outgoing are false, returns an empty set\n\n\n\n\n\n","category":"method"},{"location":"#SimpleDirectedHypergraphs","page":"Home","title":"SimpleDirectedHypergraphs","text":"Documentation for SimpleDirectedHypergraphs. For full details, see the reference.","category":"section"}]
}
